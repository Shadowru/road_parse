{"version":3,"sources":["../src/MetaParser.js"],"names":["MetaParser","constructor","Logger","useDefaults","_delta","_dict","_loadDictionaries","dict_raw","fs_extra","readJsonSync","reverse_dict","dictElement","name","type","dict","type_dict","parse","line","region_data","_cutRegion","debug","roads_data","_cutRoads","division_data","_cutDivision","places_data","_cutPlace2","regions","divisions","places","pos_cut","_findByType","data","_cutLine","cut","length","_cutPlace","mutated_line","type_element","pos","prefix","index_pos","indexOf","_simpleFindByType","undefined","start","push","delta","dict_element","_isInList","start_pos","pos_spc","_findInLine","_isEndOfWord","end","type_list","pos_line","_isSafeToInsert","token","start_idx","toLowerCase","value","values_list","includes","posLineElement","str","cutStart","cutEnd","substr","cutElement","start_cut","end_cut","cut_element","substring","char","charAt"],"mappings":"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","sourcesContent":["import Logger from \"js-logger\";\nimport fs_extra from \"fs-extra\";\n\nexport default class MetaParser {\n\n    constructor() {\n        Logger.useDefaults();\n\n        this._delta = 2;\n        this._dict = this._loadDictionaries();\n    }\n\n    _loadDictionaries() {\n\n        const dict_raw = fs_extra.readJsonSync(\n            './data/dict.json'\n        );\n\n        const reverse_dict = {};\n\n        for (const dictElement of dict_raw) {\n            reverse_dict[dictElement.name] = dictElement.type;\n        }\n\n        return {\n            reverse_dict: reverse_dict,\n            dict: dict_raw,\n            type_dict: fs_extra.readJsonSync('./data/matcher.json')\n        };\n    }\n\n    parse(line) {\n\n        const region_data = this._cutRegion(line);\n        Logger.debug('After region: ' + region_data.line);\n\n        const roads_data = this._cutRoads(region_data.line);\n\n        const division_data = this._cutDivision(region_data.line);\n\n        Logger.debug('After division: ' + division_data.line);\n\n        const places_data = this._cutPlace2(division_data.line);\n        //const places_data2 = this._cutPlace(places_data.line);\n\n        //mutated_line = this._cutPlace(mutated_line);\n        Logger.debug('Regions: ' + region_data.regions);\n        Logger.debug('Divisions: ' + division_data.divisions);\n        Logger.debug('Places: ' + places_data.places);\n        //Logger.debug('Places2: ' + places_data2.places);\n        Logger.debug('Line: ' + places_data.line);\n    }\n\n    _cutRoads(line) {\n\n    }\n\n    _cutRegion(line) {\n        const pos_cut = this._findByType(line, ['субъект РФ']);\n\n        const data = this._cutLine(line, pos_cut);\n\n        return {\n            regions: data.cut,\n            line: data.line\n        };\n    }\n\n    _cutDivision(line) {\n        const pos_cut = this._findByType(line, ['район', 'улус (р-н)']);\n\n        if (pos_cut.length > 0) {\n            const data = this._cutLine(line, [pos_cut[pos_cut.length - 1]]);\n\n            return {\n                divisions: data.cut,\n                line: data.line\n            };\n        }\n\n        return {\n            divisions: \"\",\n            line: line\n        }\n    }\n\n    _cutPlace(line) {\n        const pos_cut = this._findByType(line, ['село', 'деревня', 'город', 'сельское поселение', 'городское поселение']);\n\n        const data = this._cutLine(line, pos_cut);\n\n        return {\n            places: data.cut,\n            line: data.line\n        };\n    }\n\n    _cutPlace2(line) {\n\n        const places = [];\n\n        const type_dict = this._dict.type_dict;\n\n        let mutated_line = line;\n\n        for (const type_element of type_dict) {\n\n            let pos = 0;\n\n            while (true) {\n\n                const prefix = type_element.prefix;\n                const type = type_element.type;\n\n                const index_pos = mutated_line.indexOf(\n                    prefix,\n                    pos\n                )\n\n                if (index_pos !== -1) {\n\n                    pos = index_pos;\n\n                    const pos_cut = this._simpleFindByType(\n                        mutated_line,\n                        pos + prefix.length,\n                        type,\n                        this._delta\n                    );\n\n                    if (pos_cut !== undefined) {\n\n                        pos_cut[0].start = index_pos;\n\n                        const data = this._cutLine(line, pos_cut);\n\n                        places.push(\n                            pos_cut[0].type + ' ' + data.cut\n                        )\n\n                        mutated_line = data.line;\n\n                        mutated_line = this.cut(mutated_line, pos, pos + prefix.length);\n\n                    } else {\n                        break;\n                    }\n\n                } else {\n                    break;\n                }\n            }\n        }\n\n        return {\n            places: places,\n            line: mutated_line\n        };\n\n    }\n\n    _simpleFindByType(line, pos, type, delta) {\n        for (const dict_element of this._dict.dict) {\n            if (this._isInList(dict_element.type, type)) {\n                let start_pos = pos;\n\n                const name = dict_element.name;\n\n                const pos_spc = this._findInLine(\n                    line,\n                    start_pos,\n                    name\n                );\n\n                if (pos_spc !== undefined) {\n                    if (pos_spc.start - pos < delta + type.length) {\n                        if (this._isEndOfWord(line, pos_spc.end)) {\n\n                            pos_spc.type = dict_element.type;\n\n                            return [pos_spc];\n                        }\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n\n    _findByType(line, type_list) {\n        const pos_line = [];\n\n        for (const dict_element of this._dict.dict) {\n            if (this._isInList(dict_element.type, type_list)) {\n                let start_pos = 0;\n\n                const name = dict_element.name;\n\n                while (start_pos < name.length) {\n\n                    const pos_spc = this._findInLine(\n                        line,\n                        start_pos,\n                        name\n                    );\n\n                    if (pos_spc === undefined) {\n                        break;\n                    } else {\n                        if (this._isEndOfWord(line, pos_spc.end)) {\n                            if (this._isSafeToInsert(pos_line, pos_spc)) {\n                                pos_line.push(pos_spc);\n                            }\n                        }\n                        start_pos = pos_spc.end;\n                    }\n                }\n            }\n        }\n\n        return pos_line;\n    }\n\n    _findInLine(line, pos, token) {\n        //TODO: morphing\n        const start_idx = line.toLowerCase().indexOf(token.toLowerCase(), pos);\n        if (start_idx === -1) {\n            return undefined;\n        }\n        return {\n            start: start_idx,\n            end: start_idx + token.length\n        }\n    }\n\n    _isInList(value, values_list) {\n        return values_list.includes(value);\n    }\n\n    _isSafeToInsert(pos_line, pos_spc) {\n        for (const posLineElement of pos_line) {\n            if (pos_spc.start >= posLineElement.start && pos_spc.start <= posLineElement.end) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    cut(str, cutStart, cutEnd) {\n        return str.substr(0, cutStart) + str.substr(cutEnd + 1);\n    }\n\n    _cutLine(line, pos_cut) {\n        let mutated_line = line;\n        const data = [];\n\n        if (pos_cut.length !== 0) {\n            //Logger.debug(pos_cut);\n            let delta = 0;\n\n            //Logger.debug(pos_cut);\n\n            for (const cutElement of pos_cut) {\n\n                const start_cut = cutElement.start - delta;\n                const end_cut = cutElement.end - delta;\n\n                //Logger.debug(cutElement.start + \"/\" + cutElement.end + \" | \" + start_cut + \"/\" + end_cut);\n\n                const cut_element = mutated_line.substring(\n                    start_cut,\n                    end_cut\n                );\n\n                data.push(\n                    cut_element\n                );\n\n                mutated_line = this.cut(\n                    mutated_line,\n                    start_cut,\n                    end_cut\n                );\n\n                delta += end_cut - start_cut;\n            }\n\n        }\n\n        return {\n            cut: data,\n            line: mutated_line\n        }\n\n    }\n\n    _isEndOfWord(line, pos) {\n        if (pos === line.length) {\n            return true;\n        }\n        const char = line.charAt(pos);\n        return [' ', '.', ':'].includes(char);\n    }\n}\n"],"file":"MetaParser.js"}